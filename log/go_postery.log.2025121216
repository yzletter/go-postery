time="2025-12-12 16:00:00.008" level=INFO source=/Users/yzletter/go_project/go-postery/infra/mysql/mysql.go:101 msg="Ping MySQL 成功 ..."
time="2025-12-12 16:00:00.013" level=INFO source=/Users/yzletter/go_project/go-postery/infra/redis/redis.go:60 msg="ping globalRedisClient succeed"
time="2025-12-12 16:03:00.076" level=INFO source=/Users/yzletter/go_project/go-postery/infra/smooth/smooth.go:21 msg="signal interrupt has come, start exiting ..."
time="2025-12-12 16:03:00.077" level=INFO source=/Users/yzletter/go_project/go-postery/infra/mysql/mysql.go:115 msg="关闭 MySQL 成功 ..."
time="2025-12-12 16:03:00.077" level=INFO source=/Users/yzletter/go_project/go-postery/infra/redis/redis.go:72 msg="close globalRedisClient succeed"
time="2025-12-12 16:03:00.077" level=INFO source=/Users/yzletter/go_project/go-postery/infra/smooth/smooth.go:27 msg="all task has finished"
time="2025-12-12 16:03:32.071" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:03:32.074" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:03:32.074" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:03:32.075" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:03:32.076" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:03:32.076" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:03:32.076" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:112 LikeCount:1 CommentCount:2 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:03:32.570" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:32.570" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:32.571" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:32.571" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:32.571" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:32.572" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:03:32.573" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:32.573" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:32.573" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:32.573" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:32.573" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.106" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:33.106" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:33.106" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.106" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.106" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.107" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:03:33.108" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:33.108" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:33.108" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.108" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.108" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.819" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:33.819" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:33.819" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.819" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.819" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.820" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:03:33.820" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:33.820" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:33.820" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.820" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:33.820" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:41.932" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:41.932" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:03:41.932" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:41.932" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:22 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:03:41.932" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:10:00.011" level=INFO source=/Users/yzletter/go_project/go-postery/infra/mysql/mysql.go:101 msg="Ping MySQL 成功 ..."
time="2025-12-12 16:10:00.012" level=INFO source=/Users/yzletter/go_project/go-postery/infra/redis/redis.go:60 msg="ping globalRedisClient succeed"
time="2025-12-12 16:11:06.736" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:06.736" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:06.737" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:06.737" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:06.737" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:06.737" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:06.737" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:07.266" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:07.267" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:07.268" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:07.269" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:07.269" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:07.269" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:07.270" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:07.507" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:07.508" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:07.508" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:07.508" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:07.508" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:07.509" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:07.509" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:07.783" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:07.783" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:07.783" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:07.784" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:07.784" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:07.784" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:07.784" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:08.041" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:08.041" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.042" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.042" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:08.042" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:08.043" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:08.043" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:08.295" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:08.296" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.296" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.296" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:08.296" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:08.296" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:08.296" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:08.510" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:08.511" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.511" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.511" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:08.512" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:08.512" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:08.512" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:08.723" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:08.723" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.724" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.724" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:08.724" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:08.724" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:08.724" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:08.962" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:08.962" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.962" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:08.962" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:08.962" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:08.963" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:08.963" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:09.177" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:09.177" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:09.177" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:09.178" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:09.178" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:09.178" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:09.178" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:09.443" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:09.443" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:09.443" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:09.444" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:09.446" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:09.446" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:09.446" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:09.705" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:09.706" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:09.706" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:09.706" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:09.707" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:09.707" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:09.710" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:10.000" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:10.000" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.000" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.000" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:10.001" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:10.001" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:10.001" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:10.213" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:10.213" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.213" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.214" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:10.214" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:10.214" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:10.214" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:10.454" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:10.455" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.455" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.455" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:10.455" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:10.456" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:10.456" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:10.668" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:10.668" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.668" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.669" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:10.670" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:10.670" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:10.670" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:10.900" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:10.900" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.902" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:10.902" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:10.902" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:10.902" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:10.902" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:11.220" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:11.220" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:11.221" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:11.221" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:11.221" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:11.221" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:11.221" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:11.542" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:11.542" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:11.543" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:11.543" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:11.543" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:11.543" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:11.543" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:11.793" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:11.794" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:11.794" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:11.794" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:11.795" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:11.795" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:11.795" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:12.044" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:12.044" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:12.045" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:12.045" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:12.046" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:12.047" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:12.047" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:12.358" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:12.359" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:12.359" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:12.359" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:12.359" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:12.359" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:12.359" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:12.659" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:12.660" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:12.660" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:12.660" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:12.660" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:12.660" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:12.660" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:12.952" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:12.952" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:12.953" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:12.953" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:12.953" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:12.953" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:12.953" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:13.205" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:13.205" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:13.205" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:13.206" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:13.206" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:13.206" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:13.206" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:13.472" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:13.472" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:13.473" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:13.473" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:13.473" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:13.473" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:13.473" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:13.713" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:13.713" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:13.713" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:13.714" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:13.714" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:13.715" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:13.715" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:13.928" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:13.929" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:13.929" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:13.930" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:13.930" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:13.933" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:13.933" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:14.210" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:14.210" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:14.210" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:14.210" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:14.211" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:14.211" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:14.211" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:14.382" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:14.382" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:14.382" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:14.382" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:14.383" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:14.383" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:14.383" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:11:14.609" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:11:14.610" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:14.610" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:11:14.610" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:11:14.610" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:11:14.610" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:11:14.610" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:13:13.502" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:13:13.503" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:13:13.503" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:13:13.503" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:13:13.503" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:13:13.503" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:13:13.503" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:119 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:13:14.305" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:13:14.305" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:13:14.306" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:14.306" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:14.306" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:14.306" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:13:14.307" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:13:14.307" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:13:14.307" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:14.307" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:14.307" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:26.604" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:13:26.604" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:13:26.605" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:13:26.605" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:13:26.605" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:13:26.605" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:13:26.605" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:120 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:13:40.299" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:13:40.299" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:13:40.299" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:40.300" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:40.300" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:40.302" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:13:40.310" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:13:40.310" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:13:40.310" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:40.310" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:13:40.310" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:15.835" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:15.835" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:15.836" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:15.837" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:15.837" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:15.837" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:15.837" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:121 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:24.313" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:24.313" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:24.313" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:24.313" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:24.313" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:24.314" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:14:24.314" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:24.314" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:24.314" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:24.314" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:24.314" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:29.772" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:29.773" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:29.773" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:29.773" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:29.773" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:29.774" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:29.774" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:123 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:30.280" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:30.281" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:30.281" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:30.281" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:30.281" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:30.283" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:30.283" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:123 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:30.897" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:30.897" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:30.897" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:30.898" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:30.898" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:30.901" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:30.901" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:123 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:31.135" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:31.135" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:31.136" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:31.136" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:31.136" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:31.136" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:31.136" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:123 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:31.326" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:31.327" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:31.327" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:31.327" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:31.327" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:31.328" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:31.328" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:123 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:31.528" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:31.528" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:31.529" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:31.529" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:31.530" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:31.530" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:31.530" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:123 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:32.174" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:32.174" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:32.174" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:32.174" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:32.174" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:32.176" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:14:32.176" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:32.176" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:32.176" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:32.176" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:32.176" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:34.188" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:34.188" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:34.188" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:34.188" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:34.188" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:34.189" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:34.189" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:125 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:34.999" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:35.001" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:35.002" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:35.003" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:35.003" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:35.003" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:35.003" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:125 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:35.432" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:35.432" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:35.433" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:35.433" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:35.433" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:35.434" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:35.434" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:125 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:36.059" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:36.059" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:36.059" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:36.059" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:36.059" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:36.059" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:14:36.060" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:36.060" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:36.060" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:36.060" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:36.060" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:37.234" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:37.235" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:37.237" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:37.237" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:37.239" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:37.239" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:37.239" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:127 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:37.574" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:37.575" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:37.575" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:37.575" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:37.575" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:37.575" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:37.575" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:127 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:37.746" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:37.747" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:37.747" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:37.747" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:37.748" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:37.748" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:37.748" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:127 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:37.943" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:37.943" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:37.943" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:37.944" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:37.946" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:37.947" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:37.947" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:127 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:38.104" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:38.104" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:38.105" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:38.108" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:38.114" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:38.114" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:38.114" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:127 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:39.419" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:39.419" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:39.420" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:39.420" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:39.420" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:39.420" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:14:39.421" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:39.421" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:39.421" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:39.421" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:39.421" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:40.080" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:40.080" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:40.080" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:40.080" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:40.080" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:40.081" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:14:40.081" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:40.081" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:40.081" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:40.081" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:40.081" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:40.978" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:40.978" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:40.979" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:40.979" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:40.980" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:40.980" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:40.980" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:127 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:2 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:43.983" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:43.983" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:43.983" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:43.983" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:43.983" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:43.984" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:14:43.984" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:43.984" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:43.984" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:43.984" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:43.984" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:45.608" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:45.608" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:45.609" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:45.609" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:45.609" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:45.609" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:45.609" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:127 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:46.179" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:46.179" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:46.179" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:46.179" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:46.179" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:46.180" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:14:46.180" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:46.180" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:14:46.180" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:46.180" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:46.180" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:14:47.226" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:47.226" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:47.227" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:47.227" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:47.227" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:47.228" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:47.228" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:14:48.004" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:14:48.004" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:48.004" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:14:48.004" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:14:48.005" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:14:48.005" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:14:48.005" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:20:00.013" level=INFO source=/Users/yzletter/go_project/go-postery/infra/mysql/mysql.go:101 msg="Ping MySQL 成功 ..."
time="2025-12-12 16:20:00.015" level=INFO source=/Users/yzletter/go_project/go-postery/infra/redis/redis.go:60 msg="ping globalRedisClient succeed"
time="2025-12-12 16:20:11.004" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:20:11.006" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=2
time="2025-12-12 16:20:11.006" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=14
time="2025-12-12 16:20:11.006" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:20:11.006" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=10
time="2025-12-12 16:20:11.007" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=12
time="2025-12-12 16:20:11.007" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=4
time="2025-12-12 16:20:11.007" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=8
time="2025-12-12 16:20:11.007" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:20:11.007" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:20:11.007" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:225 ViewCount:0 LikeCount:0 CommentCount:0 Title:后端系统的容器化优化：镜像构建、资源限制与调度策略 Content:\u3000\u3000容器化已经成为服务端部署的默认方式，但许多团队的容器化实践仍然停留在“把服务塞进 Docker 再跑到 Kubernetes 上”这种简单模式。真正高质量的容器化部署需要从镜像构建、启动速度、资源限制、负载感知调度、网络通信优化、磁盘 IO 管控等多个角度进行工程化优化。\n\u3000\u3000镜像构建应尽量做到小型化。例如使用 multi-stage 构建减少层级、清除无关依赖、使用 alpine 或 distroless 镜像。镜像越小，冷启动越快，网络传输越少，部署延迟也越低。\n\u3000\u3000资源限制决定服务稳定性。如果没有合理设置 CPU limit、memory limit，服务可能因 OOM 被杀或因 CPU 抢占导致延迟不稳定。合理的 requests/limits 设置可以让调度器精准安排节点资源。\n\u3000\u3000调度策略也是容器化优化的重要部分。K8s 提供亲和性、反亲和性、污点容忍等机制，可以让服务按业务拓扑或硬件需求进行分布。例如数据库实例应避免部署在同一物理节点上。\n\u3000\u3000网络优化方面，CNI 插件（如 Calico、Cilium）对延迟影响巨大。高并发服务最好使用 eBPF 数据面增强通信性能。\n\u3000\u3000最终，容器化优化是一项系统性工程，需要理解底层运行原理与生产特性，才能真正发挥云原生部署优势。 CreatedAt:2025-11-26T17:22:42+08:00 Author:{Id:0 Name: Avatar:}} {Id:260 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能数据序列化方案：Protobuf、MsgPack 与 Avro 的对比 Content:\u3000\u3000数据序列化是服务间通信、日志存储、RPC 调用、跨语言数据交换的重要环节。一个优秀的序列化方案必须在性能、体积、兼容性、扩展性、跨语言支持等方面具备优势。常见的高性能序列化格式包括 Protobuf、MessagePack、Avro、Thrift、FlatBuffers 等。不同序列化方案适用于不同场景。\n\u3000\u3000Protobuf 是目前使用最广泛的序列化协议，它通过预定义 schema 编译生成代码，实现快速序列化与反序列化。Protobuf 的数据体积小、性能高、适合 RPC 系统如 gRPC。然而 Protobuf 的序列化结果不可读，不适用于需要人工排查的数据场景。\n\u3000\u3000MessagePack 是一种无结构的二进制序列化方案，它兼容 JSON 数据结构，但体积更小、性能更高。MsgPack 在服务通信、存储日志、缓存传输等场景得到广泛使用。由于不需要 schema，MsgPack 的灵活性更高。\n\u3000\u3000Avro 是大数据领域常用的序列化方案，基于 schema 演进设计，特别适合数据仓库、Kafka、大数据管道等场景。Avro 的 schema 可以动态演进，且支持在数据文件中内嵌 schema，方便系统跨版本兼容。\n\u3000\u3000高性能序列化方案的选择需要考虑性能需求、数据体积、跨语言要求、未来扩展性等因素。例如 RPC 调用优先使用 Protobuf；存储日志可以使用 MsgPack；大数据链路应使用 Avro。\n\u3000\u3000最终，序列化方案不是越快越好，而是需要与系统业务特点高度匹配，才能发挥最佳价值。 CreatedAt:2025-11-26T16:44:03+08:00 Author:{Id:0 Name: Avatar:}} {Id:235 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能搜索系统的查询优化：倒排索引、排序策略与缓存体系 Content:\u3000\u3000搜索系统是支撑内容平台、电商、日志分析平台的重要底层能力，其中最关键的部分是查询性能。在高 QPS 与海量数据条件下，搜索系统需要通过倒排索引、跳跃表、文档打分模型、结果缓存、Query Rewrite、分片路由策略等多种技术协同优化，才能保证低延迟响应。\n\u3000\u3000倒排索引是搜索的基础结构，包括 term 与 postings list。为了减少内存占用，通常需要对 postings 进行压缩，如 VarInt、PForDelta 等方式。为提升查询效率，则可以使用 SkipList 来支持跳跃搜索。\n\u3000\u3000排序策略（Ranking）是搜索体验的重要组成部分。经典算法如 BM25 使用词频-逆文档频率模型来衡量相关性，而现代系统越来越多地使用向量检索与深度学习模型进行语义匹配。\n\u3000\u3000缓存系统是提升搜索性能的关键。可以基于查询缓存、文档缓存、倒排段缓存、向量索引缓存构建多层次高速缓存结构。尤其是热词缓存，可以显著降低系统负载。\n\u3000\u3000搜索系统还需要合理分片。按 hash 分片适合分布均匀数据；按时间分片适合冷数据多的日志场景；按主题分片适合电商平台的多类目结构。分片策略影响查询合并成本。\n\u3000\u3000最终，搜索查询优化不是单个组件，而是计算、存储、索引、排序、缓存、路由多层次协作的结果。 CreatedAt:2025-11-26T11:40:29+08:00 Author:{Id:0 Name: Avatar:}} {Id:240 ViewCount:0 LikeCount:0 CommentCount:0 Title:消息队列的高可靠设计：投递保障、顺序一致性与延迟控制 Content:\u3000\u3000消息队列是分布式系统中的关键组件，其作用不仅在于异步解耦，还在于削峰填谷、提升系统弹性、降低耦合程度。然而随着业务复杂度增加，消息队列需要面对海量吞吐、严格顺序、一致性挑战与延迟敏感需求。设计高可靠 MQ 系统需要从生产端、Broker、消费端三个维度进行系统性优化。\n\u3000\u3000生产端的可靠性依赖确认模型。例如 Kafka 的 acks 可设置为 0、1、all，其中 all 可以保证消息在多数副本写入成功后再返回，但会降低吞吐。为了进一步增强可靠性，需要启用幂等生产者与事务性消息，避免重复写入。\n\u3000\u3000Broker 是 MQ 的核心。Kafka 使用副本机制与日志结构保证消息不丢失，使用 ISR（同步副本集）保证一致性，并通过分区分布提升吞吐。为了降低延迟，可以通过合理调整 batch.size、linger.ms、compression.type 等参数。\n\u3000\u3000顺序一致性是许多业务的要求。例如同一订单的所有事件必须按照顺序处理。Kafka 按分区保证顺序，因此只需要确保同一业务键落入同一分区。对于多分区场景，需要在消费端进行序列补偿与乱序校验。\n\u3000\u3000消费端延迟常常来自处理能力不足，因此需要使用批量消费、预取机制、线程池加速等手段。对于高风险操作，需要结合幂等机制避免重复执行。\n\u3000\u3000最终，一个高可靠 MQ 系统必须具备不丢失、不重复、可追踪、可补偿的能力。 CreatedAt:2025-11-26T10:44:17+08:00 Author:{Id:0 Name: Avatar:}} {Id:245 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能 HTTP 服务优化：线程模型、内存分配与连接复用策略 Content:\u3000\u3000HTTP 服务是大多数系统的底层通信方式，因此其性能优化至关重要。高性能 HTTP 服务不仅要提升单节点吞吐，还需要优化整体延迟、减少 GC 压力、提升连接复用能力、减轻内核网络栈负担等。随着业务规模增长，这些优化会显著改善系统的稳定性与响应能力。\n\u3000\u3000线程模型直接影响服务性能。例如基于事件驱动的模型可以减少线程上下文切换开销；基于协程模型的语言（如 Go）可以在 IO 密集场景中显著提升性能。在 Java 世界中，使用 Netty 这样基于 NIO 的框架比传统阻塞 BIO 模型性能更高。\n\u3000\u3000内存优化对于 HTTP 服务尤为关键。对象池化、减少逃逸、复用缓冲区、零拷贝机制等都能显著降低 GC 压力。在高并发场景下，频繁分配小对象会导致 GC 周期持续触发，引发延迟抖动。\n\u3000\u3000连接复用策略如 HTTP/2 的多路复用能力能显著提升带宽利用率，减少握手次数。在高请求场景下，应避免连接反复建立，而是保持长连接池，减少 TCP 握手与 TLS 握手带来的延迟开销。\n\u3000\u3000网络栈优化同样重要。使用 epoll/kqueue、开启 TCP fast open、启用 keep-alive、合理配置 backlog、使用 sendfile 提升文件传输效率，都能提升整体性能。\n\u3000\u3000最终，高性能 HTTP 服务优化是一项持续工程，需要针对系统瓶颈进行分析与调优。 CreatedAt:2025-11-26T10:03:11+08:00 Author:{Id:0 Name: Avatar:}} {Id:264 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式系统的链路压测方法论：流量录制、回放与容量评估 Content:\u3000\u3000链路压测是大型系统稳定性实践的重要环节，它可以提前识别系统瓶颈、评估扩容需求、验证架构能力、检查故障恢复能力。链路压测不仅仅是“压 QPS”，更要模拟真实流量特征、真实用户行为、真实上下游依赖与监控数据，才能做到有效评估。\n\u3000\u3000流量录制是链路压测的第一步。通过在网关层、服务层记录真实请求数据（包括参数、Header、用户特征等），可以获得真实的使用模式。然后将请求脱敏后用于压测回放。流量录制要求采样准确、覆盖全面，避免偏向单一场景。\n\u3000\u3000流量回放是压测的核心，通过将录制的流量重放到测试环境或影子环境中，能够模拟真实业务压力。回放系统需要支持压缩比变换，例如将原本每秒 1000 个请求放大到 5000 或 10000，以测试系统的最大承压能力。\n\u3000\u3000容量评估需要结合 CPU、内存、磁盘、网络、数据库、缓存、MQ 等多个层面进行。系统各节点的瓶颈不一样，例如某些场景 CPU 是瓶颈，某些场景 DB QPS 是瓶颈，某些场景则可能是 MQ 堆积导致延迟上升。\n\u3000\u3000链路压测还需要具备隔离能力。例如在生产环境进行压测时，必须确保压测流量不会影响真实业务。这需要影子表、影子消息队列、影子缓存等隔离机制。\n\u3000\u3000最终，链路压测是系统上线前最重要的验证手段，是抵御流量洪峰的核心工程能力。 CreatedAt:2025-11-25T21:45:51+08:00 Author:{Id:0 Name: Avatar:}} {Id:254 ViewCount:0 LikeCount:0 CommentCount:0 Title:大规模任务调度系统设计：任务编排、调度公平性与抢占机制 Content:\u3000\u3000任务调度系统是大型数据平台、定时处理平台、后台运营平台的重要基础设施。随着任务数量从几千增长到几十万甚至上百万级别，任务调度不仅仅是“执行定时任务”这么简单，而是需要具备任务依赖编排、优先级管理、调度公平性、抢占调度、失败恢复、可视化 DAG、跨节点调度、资源隔离等一系列工程能力。\n\u3000\u3000任务编排是调度系统的核心。许多任务并非独立执行，而是具有明确的前置依赖关系，需要通过 DAG（有向无环图）进行组织。例如任务 A 完成后要执行 B 与 C，而 B 与 C 完成后再执行 D。调度系统需要识别依赖关系并自动管理执行顺序。\n\u3000\u3000调度公平性必须在多租户场景下得到保障。例如一个租户提交大量任务不应影响其他租户任务的执行。调度算法通常包括 FIFO、公平队列、优先级调度、加权调度等，需要根据任务特性动态调整。\n\u3000\u3000抢占机制允许高优先级任务在资源紧张时中断低优先级任务。例如一个实时风控任务必须优先执行，而低优先级的离线计算任务可以被暂停。为了实现抢占，任务需要具备可恢复的能力，例如支持状态保存、断点续跑。\n\u3000\u3000为了保证高可用，调度系统需要使用主备模式、Raft 共识算法、分布式锁保证调度器不会出现多个主节点。每个任务节点也必须具备心跳机制，以便调度器感知任务状态。\n\u3000\u3000最终，大规模任务调度系统是调度器、执行器、存储、日志、监控等模块协作的综合系统工程。 CreatedAt:2025-11-25T13:14:07+08:00 Author:{Id:0 Name: Avatar:}} {Id:259 ViewCount:0 LikeCount:0 CommentCount:0 Title:边缘计算架构设计：分布式节点协同、数据裁剪与低延迟处理 Content:\u3000\u3000边缘计算是一种将计算从中心云下沉到用户附近节点的架构理念，目标是降低延迟、节省带宽、实现本地实时处理。随着 IoT、视频监控、智能制造、车联网、AR/VR 等行业的发展，边缘计算已成为新一代分布式系统的重要方向。与传统云架构相比，边缘计算需要处理更多节点、更多异构设备、更多不稳定网络环境，因此系统设计必须更加稳健。\n\u3000\u3000边缘节点通常部署在城市、基站、设备侧等位置，具备有限的 CPU、内存、存储能力。因此，需要设计轻量级计算框架，适用于低功耗、低资源的实时处理。例如对视频流进行裁剪处理、对传感器数据进行本地分析等。边缘节点的任务必须足够独立，避免大量依赖中心云。\n\u3000\u3000数据裁剪是边缘计算的重要能力。由于带宽受限，无法将所有数据完整上传至云端，因此必须在边缘完成初步分析，如过滤无效信息、提取关键特征、转换格式等。这样不仅节省网络传输，也降低中心处理压力。\n\u3000\u3000多节点协同是边缘计算的核心挑战。不同边缘节点之间需要进行数据同步、任务分配、负载均衡。由于节点数量巨大，传统中心化调度已不适用，因此常采用 P2P 协议、Gossip 协议、分布式一致性算法等进行去中心化协同。\n\u3000\u3000边缘计算系统还需要具备容错能力。例如节点掉线、网络抖动、设备异常等必须自动恢复。常见方式包括数据缓冲、本地热备份、失败重试、自动迁移等。\n\u3000\u3000最终，边缘计算不是云的替代，而是云的延伸，使整个系统形成中心云 + 边缘节点的分布式协同架构。 CreatedAt:2025-11-25T10:59:49+08:00 Author:{Id:0 Name: Avatar:}} {Id:249 ViewCount:0 LikeCount:0 CommentCount:0 Title:后端缓存体系设计：多级缓存、缓存穿透、雪崩与击穿防护 Content:\u3000\u3000缓存是后端系统提升性能最常用的手段，但错误的缓存设计可能会导致灾难级后果。例如缓存击穿会让数据库瞬间被压垮、缓存雪崩会导致系统集体超时、缓存穿透会带来无效流量攻击数据库。因此设计一套完整的缓存体系，需要从多级缓存架构、热点缓存保护、缓存更新策略、过期策略等多个角度进行系统性设计。\n\u3000\u3000多级缓存体系可以显著提升性能，例如本地缓存 + 分布式缓存 + CDN。应用首先从本地缓存读取，无法命中则查询分布式缓存，最后再访问数据库。多级缓存架构可以减少 Redis 压力，并降低整体延迟。\n\u3000\u3000缓存穿透是指查询不存在的数据，使缓存无法命中并直接访问数据库。解决方式包括布隆过滤器、空值缓存等。如果使用布隆过滤器，需要避免误判率过高；而空值缓存需要合理设置短过期时间。\n\u3000\u3000缓存击穿是指热点 Key 在过期瞬间有大量请求同时访问，从而击穿到数据库。解决方式包括互斥锁、逻辑过期、预加载更新等方式。\n\u3000\u3000缓存雪崩是大量 Key 集中过期导致数据库瞬间压力飙升。解决方式包括随机过期时间、批量预热、异步更新。\n\u3000\u3000最终，缓存体系设计不是简单“加 Redis”，而是一套包含架构、算法、策略、监控的系统工程。 CreatedAt:2025-11-25T10:09:36+08:00 Author:{Id:0 Name: Avatar:}} {Id:234 ViewCount:0 LikeCount:0 CommentCount:0 Title:系统可观测性三大支柱：Metrics、Logs 与 Tracing 的架构整合 Content:\u3000\u3000可观测性是现代分布式系统最基本也是最重要的能力。随着微服务架构不断复杂化，传统依赖日志排查的方法已远不足够。可观测性由三大核心能力组成：指标（Metrics）、日志（Logs）与链路追踪（Tracing）。只有将三者结合起来，才能形成完整的系统健康视图、性能瓶颈定位能力以及故障根因分析能力。\n\u3000\u3000Metrics 是系统的实时健康信号，包括 CPU、内存、网络、线程池、QPS、错误率、延迟分布等数据。Prometheus 是最常用的指标平台，通过拉取模型进行采集，并可通过 Alertmanager 触发告警。\n\u3000\u3000Logs 是系统行为记录，包括访问日志、业务日志、系统日志等。日志需要结构化，以便快速查询与分析。ELK、Loki 等是常用日志平台，它们提供强大的搜索能力。\n\u3000\u3000Tracing 则是分布式系统的核心，可将跨服务调用链路可视化呈现。Jaeger、Zipkin、OpenTelemetry 等工具可以记录从入口到多个微服务的完整时间序列，帮助定位哪一段耗时最多。\n\u3000\u3000现代可观测性体系不是将三者孤立存在，而是通过统一平台进行整合。例如将 TraceID 注入到 Metrics 与 Logs 中，使开发者能够快速跳转到对应链路。\n\t最终，可观测性是系统稳定性的基石，不是“排查工具”，而是“架构能力”。 CreatedAt:2025-11-24T21:11:55+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:20:11.870" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:20:11.871" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=12
time="2025-12-12 16:20:11.871" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=3
time="2025-12-12 16:20:11.871" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=8
time="2025-12-12 16:20:11.871" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=10
time="2025-12-12 16:20:11.871" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:20:11.872" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=10
time="2025-12-12 16:20:11.872" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=4
time="2025-12-12 16:20:11.873" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=8
time="2025-12-12 16:20:11.874" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=7
time="2025-12-12 16:20:11.874" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:239 ViewCount:0 LikeCount:0 CommentCount:0 Title:高可用 RPC 框架设计：连接池、负载均衡与超时控制机制 Content:\u3000\u3000RPC 是现代微服务系统中最核心的通信方式之一。一个高可用、高性能的 RPC 框架必须具备连接池、序列化协议、负载均衡、健康检查、重试机制、超时控制、链路追踪、动态路由等多项关键能力。没有合理设计的 RPC 框架，很难应对大型分布式系统的高并发压力。\n\u3000\u3000RPC 框架的第一核心能力是连接管理。客户端通常需要复用连接池，以减少建立连接的开销。连接池需要支持最小连接、最大连接、空闲检测、慢节点剔除等机制。在高并发场景下，如果连接池耗尽，会导致大量请求排队，从而形成雪崩效应。\n\u3000\u3000负载均衡是 RPC 框架的第二层能力。常见策略包括随机、轮询、权重轮询、最小连接数、基于延迟的优选路由、一致性 Hash 等。对于状态相关的请求，应使用一致性 Hash，使同一用户的请求发送到相同节点。\n\u3000\t超时控制是确保链路稳定的关键。RPC 请求不能无限等待，否则会导致资源被耗尽。因此 RPC 必须在客户端设置调用超时，同时服务端也要限制业务执行时间。一旦超时，应立即回收资源并返回错误给调用方。\n\u3000\u3000重试机制必须谨慎使用。重试对 GET 等幂等操作是安全的，但对 POST、PUT 等写操作可能造成重复执行。因此重试需要与幂等机制配合。\n\u3000\u3000健康检查与熔断机制可以在节点异常时自动隔离故障节点，避免链路进一步恶化。\n\u3000\u3000最终，一个成熟的 RPC 框架不仅要性能强，还要在复杂网络环境中保证稳定性与可用性。 CreatedAt:2025-11-24T18:30:00+08:00 Author:{Id:0 Name: Avatar:}} {Id:244 ViewCount:0 LikeCount:0 CommentCount:0 Title:CI/CD 深度实践：流水线设计、自动回滚与安全扫描体系 Content:\u3000\u3000CI/CD 流水线是现代软件工程的基础设施之一，它通过自动化测试、构建、部署、验证等步骤，使系统能够快速迭代并保持稳定。然而许多团队的 CI/CD 仍停留在表层，只做到自动构建与简单部署，缺乏自动化测试体系、环境隔离、灰度发布、自动回滚、镜像签名、安全扫描等能力。要真正发挥 CI/CD 的价值，需要从工程体系层面进行全面设计。\n\u3000\u3000CI 阶段需要覆盖静态检查、单元测试、集成测试、接口测试、安全扫描、依赖扫描等步骤。对于 Go 项目，可以使用 golangci-lint、go test、mock 组件等；对于前端项目，则需要使用 ESLint、Jest、Playwright 等测试框架。\n\u3000\u3000构建阶段需要保证构件可重复性。例如固定依赖版本、使用可重现容器构建环境、生成 SBOM（软件物料清单），并通过镜像签名保证构件来源可信。\n\u3000\u3000CD 阶段需要支持蓝绿发布、金丝雀发布、预发验证、自动回滚等能力。当新版本发布后，系统需要实时监控延迟、错误率、资源使用、下游依赖等指标，如果指标异常，需要自动触发回滚，而不是等待人工处理。\n\u3000\u3000安全扫描是现代 CI/CD 的重要能力之一，包括依赖漏洞扫描、镜像扫描、代码扫描、敏感信息泄漏检查等。CI/CD 需要将这些扫描结果与发布流程结合，使不安全版本无法上线。\n\u3000\u3000最终，CI/CD 是工程体系的核心，它的目标是让软件交付过程更高效、更安全、更可控。 CreatedAt:2025-11-24T15:48:55+08:00 Author:{Id:0 Name: Avatar:}} {Id:229 ViewCount:0 LikeCount:0 CommentCount:0 Title:现代运维平台设计：指标体系、告警规则与自动化运维流程 Content:\u3000\u3000运维平台是保证系统稳定性的核心，它负责指标收集、日志分析、链路追踪、告警触发、自动化处理等任务。一个成熟的运维平台不仅要能够监控系统健康，还要能够提前识别潜在风险，并通过自动化能力减少人工操作，从而提升系统可用性。\n\u3000\u3000指标体系是运维平台的基础。典型指标包括 CPU、内存、磁盘 IO、网络延迟、QPS、错误率、P99 延迟、队列长度等。此外还需要业务指标，例如订单创建成功率、支付成功率、库存扣减时间等。运维平台需要支持多维度指标收集与实时分析能力。\n\u3000\u3000告警体系则需要解决“告警风暴”问题。如果告警过于频繁，会导致人工忽略真正重要的问题，因此必须设计合理的阈值、分级机制、合并策略。例如 CPU 90% 持续 5 分钟才报警，而非瞬时升高就报警。\n\u3000\u3000自动化运维流程（AutoOps）则是现代运维最重要的能力之一。如自动扩容、自动故障转移、自动重启服务、自动隔离异常节点等。结合 Kubernetes 与事件驱动机制，可以将大量传统人工运维操作自动化。\n\u3000\u3000一个优秀的运维平台还需要具备可观测性能力，包括日志聚合、链路追踪、异常检测、根因分析等。使用 ELK、Loki、Prometheus、Jaeger 等工具可以构建强大的监控体系。\n\u3000\u3000最终，运维平台的目标不是给开发者“发告警”，而是通过自动化与智能化手段减少人为成本，让系统更加稳定。 CreatedAt:2025-11-24T12:50:41+08:00 Author:{Id:0 Name: Avatar:}} {Id:219 ViewCount:0 LikeCount:0 CommentCount:0 Title:服务网格在大型系统中的落地策略：Sidecar、控制面与流量治理 Content:\u3000\u3000服务网格（Service Mesh）近年来成为微服务治理的主流方案，其核心优势是将流量治理能力从业务逻辑中解耦，使服务本身更简洁，而将限流、熔断、路由、 mTLS、可观测性等功能交给 Sidecar 代理（如 Envoy）处理。服务网格对于大型企业尤为有价值，但其工程落地远比理论复杂，需要综合考虑性能、资源消耗、治理成本、改造成本等多种因素。\n\u3000\u3000Sidecar 代理模式会为每个 Pod 注入一个代理容器，用于处理所有入站与出站流量。这种模式带来的最大成本是资源消耗，因为每个 Sidecar 都会占用 CPU、内存与网络带宽。大型集群中可能会有数千个 Sidecar，所以必须进行资源预算与隔离优化。\n\u3000\u3000控制面负责生成路由规则、策略、证书、限流规则等，并将其分发到各个 Sidecar。在 Istio 中，Pilot、Citadel、Galley 等组件相互协作，但控制面本身也必须具备高可用与低延迟特性，否则会成为整个系统瓶颈。在企业实施中，通常需要搭建多集群控制面、跨区域同步策略、动态配置机制等。\n\u3000\u3000流量治理能力是 Service Mesh 的精髓，包括灰度发布、熔断、重试、故障注入、金丝雀发布等。借助 Sidecar 的透明代理特性，业务无需侵入，即可实现细粒度流量管理。例如根据用户 ID、请求路径、版本、Header 等动态拆流，实现极其灵活的灰度拓扑。\n\u3000\u3000可观测性方面，Service Mesh 提供自动化的 Metrics、Logs 与 Traces 注入能力。每个请求会自动携带 TraceID 并生成完整调用链，再由 Prometheus、Jaeger 等组件进行收集与展示。相比传统微服务体系，Mesh 能够实现更细粒度的流量可视化。\n \u3000 尽管如此，Service Mesh 并非适用于所有场景。对于轻量服务或对性能要求极高的系统，Sidecar 模式可能带来过大损耗，此时可考虑 Ambient Mesh 或轻量代理模式。\n\u3000\u3000最终，Service Mesh 的落地是一场长期工程，需要团队具备运维、网络、稳定性、治理体系等多方面能力。 CreatedAt:2025-11-24T11:11:03+08:00 Author:{Id:0 Name: Avatar:}} {Id:224 ViewCount:0 LikeCount:0 CommentCount:0 Title:微服务配置中心的设计要点：动态刷新、灰度配置与一致性模型 Content:\u3000\u3000配置中心是微服务架构中最重要的基础组件之一。随着服务数量不断增加，传统的配置文件无法满足动态性、隔离性、灰度化、可回滚等需求，因此配置中心必须提供集中化管理、动态推送、多环境隔离、细粒度权限控制、历史版本管理等能力。\n\u3000\u3000动态刷新机制决定了配置更新能否不重启生效。例如基于长轮询、推送通道、watch 机制等方式可以快速让服务实例获取新配置。不同配置中心采用的机制不同，如 Apollo 使用长轮询，Nacos 使用事件推送，Etcd 使用 watch 机制。动态刷新必须考虑并发、丢包、顺序问题。\n\u3000\u3000灰度配置允许只对部分服务实例下发新配置，通过规则选择不同节点。例如根据环境标签、机器标签、实例 ID 等方式。这使得配置变更风险大幅降低，因为可以先让小部分实例尝试新配置。\n\u3000\u3000一致性是配置中心的核心。对于数据库连接池、限流阈值等关键配置，必须保证强一致性；对于弱一致性业务配置，则可以允许 eventual consistency。Etcd 基于 Raft，因此具备强一致能力，而某些配置中心使用 CP/ AP 混合模式，需要开发者根据场景选择。\n\u3000\u3000良好的配置中心还需要具备审计能力，记录配置变更时间、操作人、变更内容等，以便出现问题时快速回溯。\n\u3000\u3000最终，配置中心不是简单的 key-value 存储，而是整个微服务体系的动态控制面。 CreatedAt:2025-11-24T09:48:21+08:00 Author:{Id:0 Name: Avatar:}} {Id:248 ViewCount:0 LikeCount:0 CommentCount:0 Title:数据库分库分表设计：路由策略、跨库事务与水平扩展实践 Content:\u3000\u3000随着数据量不断增长，数据库的单表规模可能从百万增长到千万甚至上亿，单库压力也会变得越来越大。为了保持系统性能与业务可用性，分库分表成为必不可少的架构手段。然而分库分表不仅仅是“多加几个数据库”这么简单，涉及路由规则、分片键设计、跨库事务、全局序列、全局二级索引、跨分片聚合等多个复杂工程问题。\n\u3000\u3000分片键是分库分表的第一步。分片键必须具备足够的离散性，否则会导致热点分片。例如使用用户 ID 作为 hash 分片键，可以让请求均匀分布到多个数据库；但如果使用地区 ID 作为分片键，则可能导致某些区域请求过载。设计分片键时必须结合业务访问模式进行分析。\n\u3000\u3000路由策略一般分为 hash 分片、范围分片、枚举分片等方式。hash 分片最均衡，但跨分片查询代价高；范围分片易于扩容，但容易产生热点；枚举分片适用于“按业务类别”拆分的场景。路由层必须根据分片规则将请求精准转发到对应库表。\n\u3000\u3000跨库事务是分库分表时代最大的挑战之一。传统数据库事务无法跨库，因此需要借助最终一致性策略，如本地事务 + 消息表、TCC 模型、Saga 模型等方式确保业务正确性。对于强一致性要求高的场景，则需要使用支持分布式事务的组件，如 TiDB、OceanBase 等分布式数据库。\n\u3000\u3000全局主键生成器也是分库分表的关键组件。常见方案包括雪花算法、数据库自增 ID + 业务前缀、Segment ID 方案等。在高并发情况下，需要 ID 生成器具备高吞吐、高可用、无单点的特点。\n\u3000\u3000跨库查询是常见需求。例如用户查询订单列表，订单可能分布在多个库中。为了提升效率，需要使用汇聚层（Federation Layer）对多个分片并行查询并合并结果。在更复杂场景中，还需要全局二级索引来提升查询效率。\n\u3000\u3000最终，分库分表是一个长期工程，需要配合运维、监控、扩容策略与自动化迁移能力，才能形成真正可扩展的数据库架构。 CreatedAt:2025-11-23T19:17:41+08:00 Author:{Id:0 Name: Avatar:}} {Id:253 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能消息推送系统优化：连接保持、批量推送与跨平台适配 Content:\u3000\u3000消息推送系统需要处理海量移动端设备，为用户提供即时通知与动态更新。无论是社交应用、资讯平台、交易系统还是直播平台，实时推送能力都直接影响用户体验。一个成熟的推送系统不仅需要处理百万级长连接，还要处理平台差异、消息可靠性、离线消息、推送合并、通知栏展示标准化等问题。\n\u3000\u3000连接保持是推送系统的基础。移动端设备时刻可能处于弱网、断网、切后台、休眠等状态，因此长连接必须具备心跳机制、断线重连、慢启动、网络切换感知等能力。服务端需要使用负载均衡、连接分片、路由一致性等机制管理海量连接节点。\n\u3000\u3000为了提升吞吐量，推送系统必须进行批量推送优化。对于大量用户订阅同一事件，例如直播间系统消息，推送系统应将消息批量发送到多个连接节点，而非逐个发送。服务端还可以使用“消息合并”，避免连续发送多个冗余通知。\n\u3000\u3000跨平台适配是推送系统的另一大挑战。例如 APNS、FCM、华为、小米、OPPO 各大厂商都有自己的推送通道，且各自有独立的状态码与节流策略。一个好的推送系统必须同时支持多通道调度，并在必要时从厂商通道切换为自建通道。\n\u3000\u3000为了提高投递成功率，需要使用重试机制与失败补发机制。例如推送失败时，系统应在适当间隔后自动重试，同时避免因大量重试导致爆发型推送流量。\n\u3000\u3000最终，高性能推送系统是连接层、消息层、设备层与业务层多层次协作的复杂工程。 CreatedAt:2025-11-23T18:05:52+08:00 Author:{Id:0 Name: Avatar:}} {Id:263 ViewCount:0 LikeCount:0 CommentCount:0 Title:高可扩展 API 设计：分页、过滤、去重与幂等的工程实践 Content:\u3000\u3000API 设计是后端工程中最基础却最容易被忽视的环节。一个优秀的 API 不仅要语义清晰，还要便于扩展、减少歧义、避免破坏兼容性，并具备分页、过滤、排序、去重、幂等、资源模型清晰等能力。随着业务规模上升，API 调用量巨大，优秀的 API 设计能够大幅降低后端压力、提升前端效率并提升整体开发体验。\n\u3000\u3000分页是 API 性能的基础。常见分页方式包括 offset 分页与 cursor 分页。offset 分页简单，但在大数据量下性能极差；cursor 分页通过游标定位下一页数据，性能高且避免漏数据问题。在高性能系统中，cursor 分页几乎是必选方案。\n\u3000\u3000过滤与排序需要支持灵活表达。例如可以通过 query 参数支持多字段过滤：status=paid&category=book&min_price=10。对于大型系统，则需要提供结构化过滤方式，如 JSON 过滤表达式或 DSL 查询，适用于数据分析场景。\n\u3000\u3000去重能力在内容平台中特别关键，例如推荐系统返回的数据可能存在重复，API 层需要保证结果唯一性。常见方式是对资源 ID 去重，或通过 Redis 记录最近返回结果避免重复曝光。\n\u3000\u3000幂等性是 API 可用性的关键。在转账、扣库存、支付等风险场景中，API 必须实现幂等性。常见方式包括使用 request_id、业务 ID、去重表、Token 等方式保证同一操作不会执行多次。\n\u3000\u3000最终，高可扩展 API 设计不仅是技术问题，也是工程经验的体现。 CreatedAt:2025-11-23T16:30:27+08:00 Author:{Id:0 Name: Avatar:}} {Id:233 ViewCount:0 LikeCount:0 CommentCount:0 Title:Redis 的内部运行机制：数据结构、内存模型与高可用集群原理 Content:\u3000\u3000Redis 是现代系统中最常用的缓存与高性能数据存储之一，但许多团队对它的理解停留在“key-value 缓存”层面。事实上，Redis 的内部运行机制极其复杂，包括多种高效数据结构、基于跳表的排序集合、渐进式 rehash、AOF/RDB 多模式持久化、高可用集群选举机制、Pipeline、IO 多路复用等技术能力。深入理解 Redis，可以帮助开发者更稳定地使用它，并避免线上踩坑。\n\u3000\u3000Redis 采用单线程事件模型，依赖 IO 多路复用（epoll），即便单线程也能支撑高吞吐。在内部数据结构方面，Redis 包含 SDS 动态字符串、哈希表、跳表、压缩列表、整数集合等多种结构，并会根据数据规模自动转换。例如小型 Hash 使用 ZipList 保存，节省内存；规模大时自动转换为 HashTable，以提升操作效率。\n\u3000\u3000Redis 的内存模型采用 jemalloc 管理，并通过内存分配池减少碎片。在高并发场景下，内存碎片与频繁扩容会显著影响性能，而合理的 key 设计与数据结构可以避免这些问题。\n\u3000\u3000持久化方面，RDB 提供快照方式，适合全量备份；AOF 提供增量日志方式，适合持久写入。Redis 还提供混合持久化模式，以降低恢复时间。在线上实践中，RDB 适合冷备、而 AOF 适合作为实时备份。\n\u3000\u3000Redis 高可用主要依赖 Sentinel 或 Redis Cluster。在 Sentinel 模式下，Sentinel 会监控主节点状态并自动触发主从切换；在 Cluster 模式下，Redis 使用哈希槽进行分片，并实现自动故障转移与重平衡。Cluster 的难点在于跨 slot 事务、批量命令、迁移时延迟控制等问题。\n\u3000\u3000最终，Redis 的使用不是简单存取，而是一个复杂的系统工程。理解其运行原理，才能写出真正高性能的缓存系统。 CreatedAt:2025-11-23T14:49:03+08:00 Author:{Id:0 Name: Avatar:}} {Id:243 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能对象存储系统设计：分片、纠删码与多副本协调 Content:\u3000\u3000对象存储系统已经成为大型平台数据存储的核心基础设施。无论是图片、音视频、日志文件、备份数据还是结构化文档，对象存储都能提供高可用、高吞吐、高扩展的能力。然而在 TB、PB、EB 级别的大规模存储场景中，对象存储系统需要解决分布式一致性、分片管理、元数据性能瓶颈、纠删码结构、跨机房容灾等一系列复杂问题。\n\u3000\u3000对象存储最基础的结构是对象与元数据。对象本身存储在数据节点，而元数据通常存储在独立节点，以提升查询速度。由于元数据访问频率远高于对象读取，因此元数据服务器往往成为性能瓶颈，需要采用水平扩展、多级缓存与读写分离策略进行优化。\n\u3000\u3000为了提升可用性，对象存储采用多副本机制。典型方式是 3 副本，即将数据写入三个不同节点，但这种方式成本极高，因此大规模系统通常采用纠删码（Erasure Coding）。纠删码通过数据块与校验块组合方式实现更低成本的冗余容错模型，例如 Reed-Solomon 编码能在保持较高容错率的同时显著降低存储成本。\n\u3000\u3000对象存储系统还需要实现分片机制，将对象拆成多个 chunk 存储在不同节点。分片机制不仅提高写入吞吐量，还能在读取时并发获取多个 chunk，显著提升读取速度。为了避免 chunk 分布不均导致热点，需要使用一致性哈希或分片调度算法保证负载均衡。\n\u3000\u3000跨机房容灾能力也是对象存储不可或缺的特性。不同机房之间需要进行异步复制，并在主机房宕机时快速恢复服务。对于对一致性要求高的业务，还需要支持同步双写或多主集群，以保证数据实时一致。\n\u3000\u3000最终，高性能对象存储是一个涵盖存储引擎、网络传输、纠删码算法、分布式一致性协议、容灾架构等多层次的复杂系统。 CreatedAt:2025-11-23T13:27:04+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:20:12.395" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=10
time="2025-12-12 16:20:12.396" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=14
time="2025-12-12 16:20:12.396" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=12
time="2025-12-12 16:20:12.397" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:20:12.397" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=17
time="2025-12-12 16:20:12.397" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=13
time="2025-12-12 16:20:12.398" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=17
time="2025-12-12 16:20:12.398" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:20:12.398" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:20:12.398" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=18
time="2025-12-12 16:20:12.398" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:238 ViewCount:0 LikeCount:0 CommentCount:0 Title:领域驱动设计在微服务拆分中的应用：限界上下文与模型一致性 Content:\u3000\u3000领域驱动设计（DDD）为复杂系统的架构提供了重要指导理念。随着微服务架构的广泛使用，DDD 逐渐成为系统拆分的重要方法论。而微服务拆分不是简单地“按功能拆成小服务”，而是需要构建限界上下文、领域模型、聚合根、上下文映射关系、反腐层等一整套完整设计。错误的拆分方式不仅会导致系统耦合增加，还会让团队协作混乱、业务一致性难以保证。\n\u3000\u3000限界上下文（Bounded Context）是 DDD 的核心思想，它定义了一个模型生效的语义边界。每个限界上下文代表一个独立的业务语言环境，有自己独立的数据模型、聚合规则与业务逻辑。例如订单系统、库存系统、支付系统是典型的上下文，它们不能共享数据库，也不应该共享内部实体模型。\n\u3000\u3000聚合与聚合根是确保领域模型一致性的关键。一个聚合代表一组业务上强一致的对象，而聚合根是唯一对外暴露修改能力的实体。设计不合理的聚合会导致跨服务事务、模型不一致与复杂的同步流程。例如在订单领域中，订单本身是聚合根，而订单商品列表是订单内部的实体，不应由外部系统直接操作。\n\u3000\u3000上下文映射（Context Mapping）用于描述不同上下文之间的协作关系，例如防腐层（ACL）、顺从者（Conformist）、共享内核（Shared Kernel）等模式。一个强大的上下文映射可以确保系统协作方式可控，不会产生隐式依赖。\n\u3000\u3000微服务拆分仍需考虑数据一致性问题。如果强一致性需求过高，则说明拆分不合理。例如某两个对象总是需要在一个事务中更新，那它们应该属于一个聚合，而不是两个微服务。DDD 的目标不是拆得越细越好，而是拆得恰到好处。\n\u3000\u3000最终，DDD 与微服务拆分必须结合业务战略、组织结构与工程能力，才能真正实现系统的灵活性与可扩展性。 CreatedAt:2025-11-23T10:42:58+08:00 Author:{Id:0 Name: Avatar:}} {Id:258 ViewCount:0 LikeCount:0 CommentCount:0 Title:WebAssembly 在后端与云原生场景中的应用：沙箱、安全与高性能执行 Content:\u3000\u3000WebAssembly（Wasm）最初为浏览器而生，但如今已逐渐成为后端与云原生领域最受关注的技术之一。Wasm 运行时具备轻量级沙箱、快速启动、平台无关、运行安全、可控资源限制等能力，使其在多租户执行、插件系统、边缘计算、FaaS 函数计算等场景中大放异彩。\n\u3000\u3000Wasm 的安全沙箱能力是其最大的优势。与传统虚拟机相比，Wasm 运行时占用资源更少、启动更快，且不依赖操作系统权限。对于运行 untrusted code（不受信任代码）的场景，例如用户自定义脚本执行、第三方插件、安全隔离执行等，Wasm 都能提供比传统容器更细粒度、更安全的执行环境。\n\u3000\u3000Wasm 的跨平台特性也使其成为后端应用理想的执行载体。不同语言可以编译为 Wasm 模块，如 Rust、Go、C/C++、AssemblyScript 等，模块可以在任何支持 Wasm 的运行时执行。服务端可以利用这一能力构建可扩展插件系统，例如数据库扩展、API 执行策略、数据清洗逻辑、业务脚本等。\n\t在云原生领域，Wasm 被用于构建 Serverless 与 FaaS 系统。由于 Wasm 冷启动极快，可以成倍提升函数调用响应速度。与容器相比，Wasm 不需要完整系统镜像和昂贵的启动开销，适合高密度运行成千上万个轻量任务。\n\u3000\u3000Wasm 的运行时生态也在快速发展，包括 Wasmtime、WasmEdge、Node-Wasm、SpiderMonkey-Wasm 等，它们提供宿主调用、IO 能力、插件接口、网络能力等更多功能，使 Wasm 不再局限于单纯计算逻辑。\n\u3000\u3000随着企业对安全、资源隔离、高性能执行的需求不断增加，Wasm 很可能成为未来系统执行环境的新标准。 CreatedAt:2025-11-23T09:41:07+08:00 Author:{Id:0 Name: Avatar:}} {Id:228 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析 API 安全体系：身份认证、授权模型与数据防护 Content:\u3000\u3000API 是系统对外暴露的入口，也是攻击者的主要目标。因此 API 安全体系必须从身份认证、授权控制、传输保护、防注入、防重放、防刷限流、数据脱敏、审计监控等方面构建完整防护能力。没有 API 安全体系的系统，很容易遭遇数据泄漏、越权访问、恶意调用等安全问题。\n\u3000\u3000身份认证是 API 安全的第一道防线。常见认证方式包括 API Key、JWT、OAuth2.0、OpenID Connect 等。简单业务可以使用 API Key，但对于用户体系复杂的业务，需要采用 OAuth2.0 进行授权管理。在 JWT 模型中，服务端不需要保存会话，而是通过签名验证保证 Token 的合法性，但同时需要合理配置过期时间并配合刷新 Token 机制。\n\u3000\u3000授权模型是第二道防线。基于 RBAC、ABAC 或 PBAC 的权限体系可以确保用户只能操作被允许的资源。例如管理员可以操作所有配置，一般用户只能操作自己所属的数据。授权模型必须结合 URL、方法、资源属性等多维度进行判定。\n\u3000\u3000为了保证传输安全，API 必须强制使用 HTTPS，避免中间人攻击。对于更高的安全需求，还需要启用双向 TLS，对客户端证书进行校验。\n\u3000\u3000防重放攻击也是 API 安全的重要环节。攻击者可能截获请求并重复发送，从而执行恶意操作。因此需要在请求中加入时间戳、随机数、消息签名，并在服务端通过缓存或表记录校验。\n\u3000\u3000API 还需要使用限流策略防止恶意刷接口。在网关层可以根据 IP、用户 ID、地域等维度进行限流，同时配合验证码、行为分析等方式增强安全性。\n\u3000\u3000数据安全则包括脱敏、加密存储、字段过滤、最小权限原则等。敏感字段如手机号、身份证、邮箱等都必须使用掩码或加密。\n\u3000\u3000最终，API 安全是一个系统工程，而不仅仅是简单的接口加密。需要从认证、授权、传输、风控、审计全链路构建完整体系。 CreatedAt:2025-11-23T08:29:10+08:00 Author:{Id:0 Name: Avatar:}} {Id:252 ViewCount:0 LikeCount:0 CommentCount:0 Title:容器网络深度解析：CNI、Overlay、Service Mesh 与 eBPF 数据平面 Content:\u3000\u3000容器网络是现代云原生架构的核心基础模块之一。随着 Kubernetes 在各类系统中普及，容器网络需要处理跨节点通信、服务发现、流量转发、策略控制、多集群互通等复杂任务。为了实现高性能与高可靠，容器网络基于 CNI、Overlay、Underlay、Service Mesh、eBPF 数据面等技术形成了多层次架构。\n\u3000\u3000容器网络的基础来自 CNI（Container Network Interface）。CNI 插件负责为 Pod 分配 IP、配置路由规则、管理网桥等。常见 CNI 插件包括 Flannel、Calico、Cilium、Weave 等，它们分别采用不同数据路径构建容器之间的网络通信。例如 Flannel 使用简单的 Overlay 隧道；而 Calico 使用 BGP 实现高性能的三层网络能力。\n\u3000\u3000Overlay 网络通过 VXLAN 或 IPIP 隧道封装，实现跨节点网络互通。虽然 Overlay 网络配置简单，但会引入一定的封包开销，影响性能。因此在大型系统中，常常使用 Underlay 网络或通过 Cilium 的 eBPF 数据面提升性能。\n\u3000\u3000Service Mesh 进一步增强了容器网络能力。通过 Sidecar，应用之间的通信流量可以被透明代理，实现负载均衡、流量治理、认证授权、链路追踪等能力。然而 Sidecar 带来的网络开销也非常显著，因此现代 Mesh 正在逐渐转向无 Sidecar 架构，通过 Cilium、eBPF 等技术在内核层直接处理服务通信。\n\u3000\u3000eBPF 是现代容器网络最革命性的技术。它允许开发者在内核中动态加载程序执行网络逻辑，从而绕过传统 iptables 带来的开销。Cilium 基于 eBPF 实现了高性能的网络过滤、路由、负载均衡与可观测性，是未来网络体系发展的重要方向。\n\u3000\u3000最终，一个优秀的容器网络体系需要同时考虑性能、稳定性、安全性与可观测性，不能仅关注单个点的实现。 CreatedAt:2025-11-22T17:16:33+08:00 Author:{Id:0 Name: Avatar:}} {Id:218 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式缓存系统设计：多级缓存、失效策略与高可用方案 Content:\u3000\u3000缓存系统是高并发架构中最重要的组件之一，它能够承担大量读流量，从而减少数据库压力。但随着业务规模扩大，单级缓存往往无法承载高吞吐，也难以应对复杂的数据一致性问题。因此现代系统普遍采用多级缓存设计，例如本地缓存 + Redis 缓存 + CDN 缓存的组合方式。多级缓存既能降低延迟，又能提升可用性，但同时也带来了更复杂的数据同步与失效机制。\n\u3000\u3000本地缓存的优点是速度极快、无网络开销，适合存储高频访问的小数据结构。然而本地缓存容易造成多节点数据不一致，因此需要结合广播机制或订阅机制进行同步，如基于 Redis 发布订阅或消息队列实现失效通知。\n\u3000\u3000Redis 作为分布式缓存，是热点抵抗的核心层。为了提升性能，需要使用合理的数据结构，如 hash、zset、bitmap、hyperloglog 等，以减少序列化成本。在高并发场景中，还需要使用 pipeline、批量读取、连接池等策略降低网络开销。\n\u3000\u3000缓存一致性是分布式缓存最难的问题之一。例如更新数据库后再删除缓存的双删策略、基于 Binlog 的异步同步机制、本地缓存的版本号策略等。为了避免缓存击穿，需要使用互斥锁、单飞请求、预加载策略等；避免缓存雪崩则可通过随机过期时间、分区过期等方式解决。\n\u3000\u3000缓存高可用离不开集群部署。Redis Cluster 提供分片与副本机制，通过一致性 Hash 或 jump Hash 做分片。但在主从切换时可能出现短暂不可用，因此需要合理配置超时时间与重试策略。对于更高要求场景，可采用多机房部署与多活架构，通过 proxy 层实现智能路由。\n\u3000\u3000最终，分布式缓存系统不仅是简单的 key-value 服务，而是一个包含分片、同步、失效、扩容、容灾的综合系统工程。 CreatedAt:2025-11-22T16:58:44+08:00 Author:{Id:0 Name: Avatar:}} {Id:223 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能日志采集系统架构：Filebeat、Kafka 与 ES 的深度协作 Content:\u3000\u3000在大型系统中，日志不仅是排查问题的手段，更是业务洞察、监控告警、风控分析的重要数据源。然而日志采集过程往往伴随着高并发、高吞吐、大量磁盘 IO、网络传输压力等问题，因此构建一个高性能、可扩展、可容错的日志采集系统十分关键。常见的日志采集架构包括 Filebeat + Kafka + Elasticsearch（或 Loki），其设计思想充分体现了现代日志系统的工程化能力。\n\u3000\u3000Filebeat 是轻量日志采集器，它负责将操作系统文件增量读取并推送至 Kafka。为了提高性能，Filebeat 使用多 harvester 模型，并支持多种输入源。它具备断点继续、日志截断检测、文件轮转处理等能力。在高并发场景下，需要合理配置缓冲区大小、批次大小、背压策略等，以避免读取速度不及写入速度。\n\u3000\u3000Kafka 是日志流转的中枢。在 TB 级日志场景中，Kafka 具备极高的写入性能与水平扩展能力。每条日志写入 Kafka 后都会进入分区，而分区数量决定 Kafka 的并行处理能力。为了保证日志顺序，需要控制分区策略；为了提升吞吐，需要提高 batch.size 与 linger.ms 设置。\n\u3000\u3000Elasticsearch 是日志检索的底层存储。它通过倒排索引实现高性能查询，但同时也是整个链路中最容易出现瓶颈的组件。例如写入过快可能导致 ES merge 频繁，导致 CPU 飙升；字段过多会导致 mapping 膨胀；数据冷热分层不合理会导致成本激增。因此需要配合 ILM 生命周期管理，对老旧日志进行降频索引或迁移到冷数据存储。\n\u3000\u3000日志链路还需要考虑容错能力。例如 Kafka 副本机制保证消息不丢；Filebeat 需要确保 ACK 后才删除游标；ES 集群需要启用多副本避免节点故障导致数据丢失。此外，还需要对链路每一段进行监控，例如 Filebeat backlog、Kafka 堆积量、ES 写入延迟等。\n\u3000\u3000最终，高性能日志系统是大规模平台的必备基础设施，合理设计链路、监控瓶颈、优化存储，将决定整个系统的可观测性能力。 CreatedAt:2025-11-22T11:55:32+08:00 Author:{Id:0 Name: Avatar:}} {Id:247 ViewCount:0 LikeCount:0 CommentCount:0 Title:GraphQL 在大型系统中的实践：查询优化、Schema 设计与权限模型 Content:\u3000\u3000GraphQL 是一种强大的 API 查询语言，它允许客户端以声明式方式指定所需数据，大幅减少冗余字段的传输，同时提升前后端协作效率。然而在大型系统中使用 GraphQL 并非易事，它在 Schema 设计、解析性能、N+1 查询问题、权限控制、缓存策略等方面都需要复杂的工程实践，才能真正发挥其优势。\n\u3000\u3000GraphQL 的核心是 Schema。Schema 定义了所有查询、变更、类型结构、字段、参数类型等。优秀的 Schema 应该既表达清晰的业务模型，又保持长期可扩展性。在系统规模增长时，Schema 会不断膨胀，因此需要模块化拆分、领域化管理与依赖清晰的结构。避免“巨型 Schema”是 GraphQL 成功的关键之一。\n\u3000\u3000GraphQL 最大的挑战之一是 N+1 查询问题。例如获取 100 个订单信息，并同时获取每个订单的用户信息，如果没有优化，则会导致 1 个查询变成 101 个查询，性能将显著下降。因此需要使用 DataLoader、批量查询、关系缓存等方式减少数据库压力。\n\u3000\u3000GraphQL 的解析器（Resolver）性能直接影响整体延迟。Resolver 应尽量保持无状态、快速返回，避免在 Resolver 中执行复杂业务逻辑，而是调用下游服务来完成实际处理。Resolver 还应具备并发执行能力，以提升整体吞吐量。\n\u3000\u3000权限控制是企业级 GraphQL 应用必须解决的问题。由于 GraphQL 允许客户端自由组合查询字段，因此权限校验必须精确到字段级别。例如用户可以查询订单金额，但不能查询订单的内部审核信息。需要基于 Schema 的权限模型，在每个字段绑定访问规则，通过中间件或自定义验证器进行校验。\n\u3000\u3000缓存策略是 GraphQL 性能的另一个关键点。由于 GraphQL 查询结构多变，传统 URL 缓存策略不再适用，因此需要构建查询签名缓存系统，将查询结构序列化后作为缓存 key。对于节点级缓存，还可以对单个对象进行缓存，以提高命中率。\n\u3000\u3000最终，GraphQL 在大型系统中不是 REST 的替代品，而是一套更灵活、更高效、更表达业务语义的 API 模型，但需要大量工程实践才能真正落地。 CreatedAt:2025-11-22T08:48:33+08:00 Author:{Id:0 Name: Avatar:}} {Id:257 ViewCount:0 LikeCount:0 CommentCount:0 Title:高可靠分布式锁设计：基于 Redis、Etcd 与数据库的实现对比 Content:\u3000\u3000分布式锁是大型分布式系统中重要的协调机制，用于保证在多节点并发环境下共享资源的一致性。典型场景包括订单扣库存、任务幂等执行、用户排他行为、一次性触发逻辑等。没有可靠的分布式锁，系统在高并发下容易出现数据竞争、重复执行甚至数据错乱。要设计可靠的分布式锁，需要深入理解 Redis、Etcd、Zookeeper、数据库等不同实现方式的优缺点。\n\u3000\u3000Redis 分布式锁是最常用方式，通过 SET NX PX 命令实现加锁并设置过期时间。但 Redis 锁存在“自动过期导致互斥失败”、“客户端执行耗时超过锁 TTL”、“网络抖动导致锁提前释放”等潜在问题。为解决这些问题，可以使用 RedLock 算法，它通过多个 Redis 节点签发锁，提高锁的可靠性，但是对于网络分区场景仍存在争议。\n\u3000\u3000Etcd 基于 Raft 共识算法，提供强一致性，因此在需要严格分布式协调的场景下非常适合。Etcd 的分布式锁通过租约（Lease）机制维持锁有效性，客户端可以自动续租，避免锁超时导致的错误释放。Etcd 的缺点是性能较 Redis 低，但一致性更强。\n\u3000\u3000数据库锁通常基于唯一索引或悲观锁实现。使用唯一约束可以通过插入一条记录获取锁，通过删除记录释放锁，这种方式强一致，但性能有限。同时数据库锁不适合高吞吐场景，不适合服务层频繁调用。\n\u3000\u3000Zookeeper 是另一种强一致协调服务，通过临时节点与 Watch 机制实现分布式锁，具备强一致性，但维护成本较高，使用复杂度也较高。\n\u3000\u3000选择分布式锁方案需要结合业务场景：若对一致性要求很高，例如支付、金融业务，应使用 Etcd 或 Zookeeper；若追求高性能，可采用 Redis + 看门狗续租机制；若需要简单可控，可使用数据库锁。\n\u3000\u3000最终，分布式锁本质是在不可靠网络环境下保证资源互斥，其设计必须考虑一致性、可用性、性能、容错能力等多重因素。 CreatedAt:2025-11-21T22:58:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:237 ViewCount:0 LikeCount:0 CommentCount:0 Title:数据库索引优化实战：覆盖索引、联合索引与执行计划调优 Content:\u3000\u3000数据库查询性能高度依赖索引结构，但许多开发者对索引的理解停留在“建索引可以加速查询”这一层面。然而在复杂业务环境下，索引设计远比想象中复杂。例如什么时候该建联合索引？索引顺序如何决定？什么时候会导致索引失效？覆盖索引如何减少回表？执行计划应该如何分析？这些问题都直接影响 SQL 性能和系统稳定性。\n\u3000\u3000索引的核心价值是减少扫描范围。InnoDB 的 B+ 树结构允许数据库快速定位到符合条件的记录。然而联合索引的顺序并不是随意排列的，而是根据最左前缀原则。例如索引 (a, b, c)，只有在 where 条件中包含 a 时才能使用完整索引；如果只查询 b，则无法使用该索引。因此在设计联合索引时需要分析查询条件模式，确保高频条件字段在前。\n\u3000\u3000覆盖索引是另一个关键性能机制。如果查询字段全部包含在索引中，那么数据库可以直接从索引中返回结果，无需回表，从而大幅减少 IO。为了实现覆盖索引，通常需要将查询字段与过滤字段放入同一个联合索引。但这也会带来写入压力，因此设计时必须平衡读写需求。\n\u3000\u3000执行计划分析是优化 SQL 的重要步骤。通过 explain 可以查看索引使用情况、扫描行数、是否使用回表、是否触发 using filesort、是否触发 using temporary 等关键信息。例如 type=ALL 表示全表扫描，而 type=ref 或 range 表示索引已生效。rows 字段可以估算扫描数据量，影响数据库是否能够快速返回结果。\n\u3000\u3000索引失效也是常见问题。例如 where name like '%abc' 会导致无法走索引；对字段进行函数处理，如 where DATE(time)=… 也会使索引失效；字段类型不匹配也会造成 optimizer 放弃使用索引。在复杂条件下，优化器可能会因为统计信息不准确而错误选择索引，此时可以通过分析与强制索引来修正。\n\u3000\u3000为了提升更新性能，需要避免为高写入频率表建过多索引，因为每次写入都会导致索引更新。对于实时性要求高的系统，需要对索引数量进行严格控制。\n\u3000\u3000最终，数据库索引优化不是单次行为，而是一个不断分析执行计划、调整索引策略、理解业务查询模型的过程。只有掌握索引底层原理，才能真正让数据库性能保持稳定。 CreatedAt:2025-11-21T20:09:24+08:00 Author:{Id:0 Name: Avatar:}} {Id:222 ViewCount:0 LikeCount:0 CommentCount:0 Title:大型系统中的权限模型设计：RBAC、ABAC 与多租户隔离方案 Content:\u3000\u3000权限系统是大型业务系统中的核心基础设施，它直接影响系统安全性、数据隔离能力、跨部门协作能力以及未来可扩展性。然而许多团队往往将权限系统设计得过于简单，例如只用角色+权限的模式，导致业务复杂后无法维持灵活性，也无法支持多租户架构、细粒度资源权限控制、动态策略管理等需求。设计一个真正可扩展的权限系统，需要深入理解 RBAC、ABAC、PBAC 等不同权限模型。\n\u3000\u3000RBAC（基于角色的访问控制）是最常见的权限模型，通过用户—角色—权限三者绑定实现授权。然而 RBAC 的缺点是角色数量随业务扩张呈指数增长，最终导致大量难以管理的角色，例如“客服主管 A 区域批量审核权限”。因此 RBAC 在大型企业中往往不够灵活。\n\u3000\u3000ABAC（基于属性的访问控制）是更灵活的权限模型，它通过用户属性、资源属性、环境属性以及策略规则进行授权判断。例如“允许用户在其所属部门内查看资源”，这种动态策略可以适应复杂业务变化。ABAC 的关键在于策略引擎，它通常需要解析 DSL 或策略语法，例如 OPA（Open Policy Agent）或自研策略引擎。\n\u3000\u3000多租户权限系统是更复杂的需求。在 SaaS 系统中，多个企业共享同一套服务，因此必须确保不同租户间的数据强隔离。隔离方式包括逻辑隔离（字段带租户 ID）、库表隔离、实例隔离等。权限系统需要同时支持租户内权限管理与系统级权限控制。因此租户管理员需要具备自定义角色、权限范围配置等能力。\n\u3000\u3000为了兼顾安全性与性能，权限系统需要设计缓存机制。复杂权限判断不能每次都依赖数据库，否则会造成高延迟。可以通过权限快照、策略缓存、智能失效机制提高性能。同时需要支持实时权限变更，例如用户角色被禁用后应立即生效。\n\u3000\u3000最终，权限系统不是简单功能，而是一个影响全系统的底层平台。优秀的权限模型需要灵活、可配置、可扩展，并具备强安全性保障。 CreatedAt:2025-11-21T18:01:49+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:29:15.118" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:29:15.119" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:15.119" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:15.119" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:29:15.120" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:29:15.120" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:29:15.120" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:29:17.760" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:17.760" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:17.760" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:17.760" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:17.760" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:17.761" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:29:17.761" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:17.761" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:17.761" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:17.761" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:17.761" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:18.334" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:18.334" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:18.334" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:18.334" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:18.334" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:18.335" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:29:18.335" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:18.335" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:18.335" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:18.336" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:18.336" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:19.741" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:29:19.742" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:19.742" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:19.742" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:29:19.742" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:29:19.743" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:29:19.743" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:8 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:29:20.212" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:29:20.212" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:20.213" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:20.213" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:29:20.213" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:29:20.214" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:29:20.214" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:8 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:73 msg="AuthService 认证 AccessToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:80 msg="AuthService 认证 AccessToken 失败, 尝试认证 RefreshToken ..."
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/service/jwt.go:137 msg="verify payload" !BADKEY="{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:46 msg="AuthService 校验 JWT Token 成功 ..." payload="&{ID: Issue:yzletter Audience: Subject: IssueAt:1765500099 NotBefore:0 Expiration:0 UserDefined:map[userInfo:map[Name:yzletter id:1998783378609930240]]}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/service/auth.go:55 msg="AuthService 获得 UserInfo 成功 ... " userInfo="{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:104 msg="AuthService 认证 RefreshToken 成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:21.304" level=INFO source=/Users/yzletter/go_project/go-postery/middleware/auth.go:116 msg="用户信息放入上下文成功 ..." UserInfo="&{Id:1998783378609930240 Name:yzletter}"
time="2025-12-12 16:29:22.601" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:29:22.601" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:22.602" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:22.603" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:29:22.603" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:29:22.603" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:29:22.603" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:10 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:29:24.075" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:29:24.075" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:24.075" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:24.075" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:29:24.076" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:29:24.076" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:29:24.076" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:10 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:29:28.090" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:29:28.091" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:28.091" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:29:28.091" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:29:28.092" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:29:28.092" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:29:28.092" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:10 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:29:40.245" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:29:40.245" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=2
time="2025-12-12 16:29:40.245" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=14
time="2025-12-12 16:29:40.246" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:29:40.246" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=10
time="2025-12-12 16:29:40.246" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=12
time="2025-12-12 16:29:40.247" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=4
time="2025-12-12 16:29:40.247" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=8
time="2025-12-12 16:29:40.247" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:29:40.247" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=6
time="2025-12-12 16:29:40.247" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:225 ViewCount:0 LikeCount:0 CommentCount:0 Title:后端系统的容器化优化：镜像构建、资源限制与调度策略 Content:\u3000\u3000容器化已经成为服务端部署的默认方式，但许多团队的容器化实践仍然停留在“把服务塞进 Docker 再跑到 Kubernetes 上”这种简单模式。真正高质量的容器化部署需要从镜像构建、启动速度、资源限制、负载感知调度、网络通信优化、磁盘 IO 管控等多个角度进行工程化优化。\n\u3000\u3000镜像构建应尽量做到小型化。例如使用 multi-stage 构建减少层级、清除无关依赖、使用 alpine 或 distroless 镜像。镜像越小，冷启动越快，网络传输越少，部署延迟也越低。\n\u3000\u3000资源限制决定服务稳定性。如果没有合理设置 CPU limit、memory limit，服务可能因 OOM 被杀或因 CPU 抢占导致延迟不稳定。合理的 requests/limits 设置可以让调度器精准安排节点资源。\n\u3000\u3000调度策略也是容器化优化的重要部分。K8s 提供亲和性、反亲和性、污点容忍等机制，可以让服务按业务拓扑或硬件需求进行分布。例如数据库实例应避免部署在同一物理节点上。\n\u3000\u3000网络优化方面，CNI 插件（如 Calico、Cilium）对延迟影响巨大。高并发服务最好使用 eBPF 数据面增强通信性能。\n\u3000\u3000最终，容器化优化是一项系统性工程，需要理解底层运行原理与生产特性，才能真正发挥云原生部署优势。 CreatedAt:2025-11-26T17:22:42+08:00 Author:{Id:0 Name: Avatar:}} {Id:260 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能数据序列化方案：Protobuf、MsgPack 与 Avro 的对比 Content:\u3000\u3000数据序列化是服务间通信、日志存储、RPC 调用、跨语言数据交换的重要环节。一个优秀的序列化方案必须在性能、体积、兼容性、扩展性、跨语言支持等方面具备优势。常见的高性能序列化格式包括 Protobuf、MessagePack、Avro、Thrift、FlatBuffers 等。不同序列化方案适用于不同场景。\n\u3000\u3000Protobuf 是目前使用最广泛的序列化协议，它通过预定义 schema 编译生成代码，实现快速序列化与反序列化。Protobuf 的数据体积小、性能高、适合 RPC 系统如 gRPC。然而 Protobuf 的序列化结果不可读，不适用于需要人工排查的数据场景。\n\u3000\u3000MessagePack 是一种无结构的二进制序列化方案，它兼容 JSON 数据结构，但体积更小、性能更高。MsgPack 在服务通信、存储日志、缓存传输等场景得到广泛使用。由于不需要 schema，MsgPack 的灵活性更高。\n\u3000\u3000Avro 是大数据领域常用的序列化方案，基于 schema 演进设计，特别适合数据仓库、Kafka、大数据管道等场景。Avro 的 schema 可以动态演进，且支持在数据文件中内嵌 schema，方便系统跨版本兼容。\n\u3000\u3000高性能序列化方案的选择需要考虑性能需求、数据体积、跨语言要求、未来扩展性等因素。例如 RPC 调用优先使用 Protobuf；存储日志可以使用 MsgPack；大数据链路应使用 Avro。\n\u3000\u3000最终，序列化方案不是越快越好，而是需要与系统业务特点高度匹配，才能发挥最佳价值。 CreatedAt:2025-11-26T16:44:03+08:00 Author:{Id:0 Name: Avatar:}} {Id:235 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能搜索系统的查询优化：倒排索引、排序策略与缓存体系 Content:\u3000\u3000搜索系统是支撑内容平台、电商、日志分析平台的重要底层能力，其中最关键的部分是查询性能。在高 QPS 与海量数据条件下，搜索系统需要通过倒排索引、跳跃表、文档打分模型、结果缓存、Query Rewrite、分片路由策略等多种技术协同优化，才能保证低延迟响应。\n\u3000\u3000倒排索引是搜索的基础结构，包括 term 与 postings list。为了减少内存占用，通常需要对 postings 进行压缩，如 VarInt、PForDelta 等方式。为提升查询效率，则可以使用 SkipList 来支持跳跃搜索。\n\u3000\u3000排序策略（Ranking）是搜索体验的重要组成部分。经典算法如 BM25 使用词频-逆文档频率模型来衡量相关性，而现代系统越来越多地使用向量检索与深度学习模型进行语义匹配。\n\u3000\u3000缓存系统是提升搜索性能的关键。可以基于查询缓存、文档缓存、倒排段缓存、向量索引缓存构建多层次高速缓存结构。尤其是热词缓存，可以显著降低系统负载。\n\u3000\u3000搜索系统还需要合理分片。按 hash 分片适合分布均匀数据；按时间分片适合冷数据多的日志场景；按主题分片适合电商平台的多类目结构。分片策略影响查询合并成本。\n\u3000\u3000最终，搜索查询优化不是单个组件，而是计算、存储、索引、排序、缓存、路由多层次协作的结果。 CreatedAt:2025-11-26T11:40:29+08:00 Author:{Id:0 Name: Avatar:}} {Id:240 ViewCount:0 LikeCount:0 CommentCount:0 Title:消息队列的高可靠设计：投递保障、顺序一致性与延迟控制 Content:\u3000\u3000消息队列是分布式系统中的关键组件，其作用不仅在于异步解耦，还在于削峰填谷、提升系统弹性、降低耦合程度。然而随着业务复杂度增加，消息队列需要面对海量吞吐、严格顺序、一致性挑战与延迟敏感需求。设计高可靠 MQ 系统需要从生产端、Broker、消费端三个维度进行系统性优化。\n\u3000\u3000生产端的可靠性依赖确认模型。例如 Kafka 的 acks 可设置为 0、1、all，其中 all 可以保证消息在多数副本写入成功后再返回，但会降低吞吐。为了进一步增强可靠性，需要启用幂等生产者与事务性消息，避免重复写入。\n\u3000\u3000Broker 是 MQ 的核心。Kafka 使用副本机制与日志结构保证消息不丢失，使用 ISR（同步副本集）保证一致性，并通过分区分布提升吞吐。为了降低延迟，可以通过合理调整 batch.size、linger.ms、compression.type 等参数。\n\u3000\u3000顺序一致性是许多业务的要求。例如同一订单的所有事件必须按照顺序处理。Kafka 按分区保证顺序，因此只需要确保同一业务键落入同一分区。对于多分区场景，需要在消费端进行序列补偿与乱序校验。\n\u3000\u3000消费端延迟常常来自处理能力不足，因此需要使用批量消费、预取机制、线程池加速等手段。对于高风险操作，需要结合幂等机制避免重复执行。\n\u3000\u3000最终，一个高可靠 MQ 系统必须具备不丢失、不重复、可追踪、可补偿的能力。 CreatedAt:2025-11-26T10:44:17+08:00 Author:{Id:0 Name: Avatar:}} {Id:245 ViewCount:0 LikeCount:0 CommentCount:0 Title:高性能 HTTP 服务优化：线程模型、内存分配与连接复用策略 Content:\u3000\u3000HTTP 服务是大多数系统的底层通信方式，因此其性能优化至关重要。高性能 HTTP 服务不仅要提升单节点吞吐，还需要优化整体延迟、减少 GC 压力、提升连接复用能力、减轻内核网络栈负担等。随着业务规模增长，这些优化会显著改善系统的稳定性与响应能力。\n\u3000\u3000线程模型直接影响服务性能。例如基于事件驱动的模型可以减少线程上下文切换开销；基于协程模型的语言（如 Go）可以在 IO 密集场景中显著提升性能。在 Java 世界中，使用 Netty 这样基于 NIO 的框架比传统阻塞 BIO 模型性能更高。\n\u3000\u3000内存优化对于 HTTP 服务尤为关键。对象池化、减少逃逸、复用缓冲区、零拷贝机制等都能显著降低 GC 压力。在高并发场景下，频繁分配小对象会导致 GC 周期持续触发，引发延迟抖动。\n\u3000\u3000连接复用策略如 HTTP/2 的多路复用能力能显著提升带宽利用率，减少握手次数。在高请求场景下，应避免连接反复建立，而是保持长连接池，减少 TCP 握手与 TLS 握手带来的延迟开销。\n\u3000\u3000网络栈优化同样重要。使用 epoll/kqueue、开启 TCP fast open、启用 keep-alive、合理配置 backlog、使用 sendfile 提升文件传输效率，都能提升整体性能。\n\u3000\u3000最终，高性能 HTTP 服务优化是一项持续工程，需要针对系统瓶颈进行分析与调优。 CreatedAt:2025-11-26T10:03:11+08:00 Author:{Id:0 Name: Avatar:}} {Id:264 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式系统的链路压测方法论：流量录制、回放与容量评估 Content:\u3000\u3000链路压测是大型系统稳定性实践的重要环节，它可以提前识别系统瓶颈、评估扩容需求、验证架构能力、检查故障恢复能力。链路压测不仅仅是“压 QPS”，更要模拟真实流量特征、真实用户行为、真实上下游依赖与监控数据，才能做到有效评估。\n\u3000\u3000流量录制是链路压测的第一步。通过在网关层、服务层记录真实请求数据（包括参数、Header、用户特征等），可以获得真实的使用模式。然后将请求脱敏后用于压测回放。流量录制要求采样准确、覆盖全面，避免偏向单一场景。\n\u3000\u3000流量回放是压测的核心，通过将录制的流量重放到测试环境或影子环境中，能够模拟真实业务压力。回放系统需要支持压缩比变换，例如将原本每秒 1000 个请求放大到 5000 或 10000，以测试系统的最大承压能力。\n\u3000\u3000容量评估需要结合 CPU、内存、磁盘、网络、数据库、缓存、MQ 等多个层面进行。系统各节点的瓶颈不一样，例如某些场景 CPU 是瓶颈，某些场景 DB QPS 是瓶颈，某些场景则可能是 MQ 堆积导致延迟上升。\n\u3000\u3000链路压测还需要具备隔离能力。例如在生产环境进行压测时，必须确保压测流量不会影响真实业务。这需要影子表、影子消息队列、影子缓存等隔离机制。\n\u3000\u3000最终，链路压测是系统上线前最重要的验证手段，是抵御流量洪峰的核心工程能力。 CreatedAt:2025-11-25T21:45:51+08:00 Author:{Id:0 Name: Avatar:}} {Id:254 ViewCount:0 LikeCount:0 CommentCount:0 Title:大规模任务调度系统设计：任务编排、调度公平性与抢占机制 Content:\u3000\u3000任务调度系统是大型数据平台、定时处理平台、后台运营平台的重要基础设施。随着任务数量从几千增长到几十万甚至上百万级别，任务调度不仅仅是“执行定时任务”这么简单，而是需要具备任务依赖编排、优先级管理、调度公平性、抢占调度、失败恢复、可视化 DAG、跨节点调度、资源隔离等一系列工程能力。\n\u3000\u3000任务编排是调度系统的核心。许多任务并非独立执行，而是具有明确的前置依赖关系，需要通过 DAG（有向无环图）进行组织。例如任务 A 完成后要执行 B 与 C，而 B 与 C 完成后再执行 D。调度系统需要识别依赖关系并自动管理执行顺序。\n\u3000\u3000调度公平性必须在多租户场景下得到保障。例如一个租户提交大量任务不应影响其他租户任务的执行。调度算法通常包括 FIFO、公平队列、优先级调度、加权调度等，需要根据任务特性动态调整。\n\u3000\u3000抢占机制允许高优先级任务在资源紧张时中断低优先级任务。例如一个实时风控任务必须优先执行，而低优先级的离线计算任务可以被暂停。为了实现抢占，任务需要具备可恢复的能力，例如支持状态保存、断点续跑。\n\u3000\u3000为了保证高可用，调度系统需要使用主备模式、Raft 共识算法、分布式锁保证调度器不会出现多个主节点。每个任务节点也必须具备心跳机制，以便调度器感知任务状态。\n\u3000\u3000最终，大规模任务调度系统是调度器、执行器、存储、日志、监控等模块协作的综合系统工程。 CreatedAt:2025-11-25T13:14:07+08:00 Author:{Id:0 Name: Avatar:}} {Id:259 ViewCount:0 LikeCount:0 CommentCount:0 Title:边缘计算架构设计：分布式节点协同、数据裁剪与低延迟处理 Content:\u3000\u3000边缘计算是一种将计算从中心云下沉到用户附近节点的架构理念，目标是降低延迟、节省带宽、实现本地实时处理。随着 IoT、视频监控、智能制造、车联网、AR/VR 等行业的发展，边缘计算已成为新一代分布式系统的重要方向。与传统云架构相比，边缘计算需要处理更多节点、更多异构设备、更多不稳定网络环境，因此系统设计必须更加稳健。\n\u3000\u3000边缘节点通常部署在城市、基站、设备侧等位置，具备有限的 CPU、内存、存储能力。因此，需要设计轻量级计算框架，适用于低功耗、低资源的实时处理。例如对视频流进行裁剪处理、对传感器数据进行本地分析等。边缘节点的任务必须足够独立，避免大量依赖中心云。\n\u3000\u3000数据裁剪是边缘计算的重要能力。由于带宽受限，无法将所有数据完整上传至云端，因此必须在边缘完成初步分析，如过滤无效信息、提取关键特征、转换格式等。这样不仅节省网络传输，也降低中心处理压力。\n\u3000\u3000多节点协同是边缘计算的核心挑战。不同边缘节点之间需要进行数据同步、任务分配、负载均衡。由于节点数量巨大，传统中心化调度已不适用，因此常采用 P2P 协议、Gossip 协议、分布式一致性算法等进行去中心化协同。\n\u3000\u3000边缘计算系统还需要具备容错能力。例如节点掉线、网络抖动、设备异常等必须自动恢复。常见方式包括数据缓冲、本地热备份、失败重试、自动迁移等。\n\u3000\u3000最终，边缘计算不是云的替代，而是云的延伸，使整个系统形成中心云 + 边缘节点的分布式协同架构。 CreatedAt:2025-11-25T10:59:49+08:00 Author:{Id:0 Name: Avatar:}} {Id:249 ViewCount:0 LikeCount:0 CommentCount:0 Title:后端缓存体系设计：多级缓存、缓存穿透、雪崩与击穿防护 Content:\u3000\u3000缓存是后端系统提升性能最常用的手段，但错误的缓存设计可能会导致灾难级后果。例如缓存击穿会让数据库瞬间被压垮、缓存雪崩会导致系统集体超时、缓存穿透会带来无效流量攻击数据库。因此设计一套完整的缓存体系，需要从多级缓存架构、热点缓存保护、缓存更新策略、过期策略等多个角度进行系统性设计。\n\u3000\u3000多级缓存体系可以显著提升性能，例如本地缓存 + 分布式缓存 + CDN。应用首先从本地缓存读取，无法命中则查询分布式缓存，最后再访问数据库。多级缓存架构可以减少 Redis 压力，并降低整体延迟。\n\u3000\u3000缓存穿透是指查询不存在的数据，使缓存无法命中并直接访问数据库。解决方式包括布隆过滤器、空值缓存等。如果使用布隆过滤器，需要避免误判率过高；而空值缓存需要合理设置短过期时间。\n\u3000\u3000缓存击穿是指热点 Key 在过期瞬间有大量请求同时访问，从而击穿到数据库。解决方式包括互斥锁、逻辑过期、预加载更新等方式。\n\u3000\u3000缓存雪崩是大量 Key 集中过期导致数据库瞬间压力飙升。解决方式包括随机过期时间、批量预热、异步更新。\n\u3000\u3000最终，缓存体系设计不是简单“加 Redis”，而是一套包含架构、算法、策略、监控的系统工程。 CreatedAt:2025-11-25T10:09:36+08:00 Author:{Id:0 Name: Avatar:}} {Id:234 ViewCount:0 LikeCount:0 CommentCount:0 Title:系统可观测性三大支柱：Metrics、Logs 与 Tracing 的架构整合 Content:\u3000\u3000可观测性是现代分布式系统最基本也是最重要的能力。随着微服务架构不断复杂化，传统依赖日志排查的方法已远不足够。可观测性由三大核心能力组成：指标（Metrics）、日志（Logs）与链路追踪（Tracing）。只有将三者结合起来，才能形成完整的系统健康视图、性能瓶颈定位能力以及故障根因分析能力。\n\u3000\u3000Metrics 是系统的实时健康信号，包括 CPU、内存、网络、线程池、QPS、错误率、延迟分布等数据。Prometheus 是最常用的指标平台，通过拉取模型进行采集，并可通过 Alertmanager 触发告警。\n\u3000\u3000Logs 是系统行为记录，包括访问日志、业务日志、系统日志等。日志需要结构化，以便快速查询与分析。ELK、Loki 等是常用日志平台，它们提供强大的搜索能力。\n\u3000\u3000Tracing 则是分布式系统的核心，可将跨服务调用链路可视化呈现。Jaeger、Zipkin、OpenTelemetry 等工具可以记录从入口到多个微服务的完整时间序列，帮助定位哪一段耗时最多。\n\u3000\u3000现代可观测性体系不是将三者孤立存在，而是通过统一平台进行整合。例如将 TraceID 注入到 Metrics 与 Logs 中，使开发者能够快速跳转到对应链路。\n\t最终，可观测性是系统稳定性的基石，不是“排查工具”，而是“架构能力”。 CreatedAt:2025-11-24T21:11:55+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:30:00.006" level=INFO source=/Users/yzletter/go_project/go-postery/infra/mysql/mysql.go:101 msg="Ping MySQL 成功 ..."
time="2025-12-12 16:30:00.007" level=INFO source=/Users/yzletter/go_project/go-postery/infra/redis/redis.go:60 msg="ping globalRedisClient succeed"
time="2025-12-12 16:37:23.860" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:37:23.862" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:37:23.882" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:37:23.883" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:37:23.883" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:37:23.884" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:37:23.884" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:10 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
time="2025-12-12 16:37:23.894" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9999
time="2025-12-12 16:37:23.894" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:37:23.894" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=1
time="2025-12-12 16:37:23.894" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=15
time="2025-12-12 16:37:23.895" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=9
time="2025-12-12 16:37:23.895" level=WARN source=/Users/yzletter/go_project/go-postery/service/post.go:85 msg="could not get name of user" uid=11
time="2025-12-12 16:37:23.895" level=INFO source=/Users/yzletter/go_project/go-postery/handler/post.go:41 msg="" postDTOs="[{Id:1999011797763358720 ViewCount:129 LikeCount:1 CommentCount:3 Title:帖子4 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:07+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011774690492416 ViewCount:4 LikeCount:0 CommentCount:0 Title:帖子3 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:02:02+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999011749923127296 ViewCount:10 LikeCount:0 CommentCount:0 Title:帖子2 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T15:01:56+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:1999010822646398976 ViewCount:0 LikeCount:0 CommentCount:0 Title:帖子1 Content:测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试 CreatedAt:2025-12-11T14:58:15+08:00 Author:{Id:1998783378609930240 Name:yzletter Avatar:}} {Id:266 ViewCount:0 LikeCount:0 CommentCount:0 Title:测试评论测试评论 Content:测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论测试评论 CreatedAt:2025-12-03T20:50:23+08:00 Author:{Id:0 Name: Avatar:}} {Id:250 ViewCount:0 LikeCount:0 CommentCount:0 Title:高并发系统的限流策略：漏桶算法、令牌桶与分布式限流 Content:\u3000\u3000限流是高并发系统保护自身的重要机制，用于防止短时间内的流量峰值压垮后端服务或数据库。没有限流机制的系统很容易在高峰期发生雪崩效应，导致整体宕机。常见限流算法包括漏桶算法、令牌桶算法、滑动窗口限流、分布式限流等。不同场景需要不同限流策略。\n\u3000\u3000漏桶算法（Leaky Bucket）适用于控制系统的稳定输出，将不规则流量变得平滑。当请求量超过漏桶容量时，会强制丢弃请求，从而保护系统。\n\u3000\u3000令牌桶算法（Token Bucket）更灵活，它允许流量在短时间内突发。例如允许每秒 1000 个请求，但桶中可以累计一定数量令牌用于支持突发流量。\n\u3000\u3000滑动窗口限流适用于统计一段时间内的请求数，例如过去 1 秒或过去 5 秒内的总请求量，用于做更平滑的限流策略。\n\u3000\u3000分布式限流需要依赖 Redis、Etcd 或 Service Mesh 来进行全局限流。例如使用 Redis 的 INCR + EXPIRE 实现固定窗口限流，或使用 Lua 脚本实现原子操作。\n\u3000\u3000最终，限流是系统稳定性的基石，也是处理突发流量的关键技术。 CreatedAt:2025-11-26T23:59:12+08:00 Author:{Id:0 Name: Avatar:}} {Id:230 ViewCount:0 LikeCount:0 CommentCount:0 Title:深度解析系统性能优化：CPU、内存、IO 与网络的全链路调优策略 Content:\u3000\u3000系统性能优化是一项贯穿整个工程生命周期的核心能力。无论是服务器端、数据库、缓存系统还是网络层，性能瓶颈可能出现在任意环节。因此性能优化必须从 CPU、内存、IO、网络四大维度进行系统化分析。\n\u3000\u3000CPU 优化包括减少上下文切换、避免锁竞争、提高缓存命中率、减少无效计算、并行化处理。例如在多线程场景下应使用无锁结构或分段锁；在数据密集型任务中使用 SIMD 指令可以显著提升性能。\n\u3000\u3000内存优化则包括减少 GC 压力、避免内存碎片、优化对象生命周期。对于 Go 语言、Java 等 GC 语言，需要减少逃逸分配、使用池化、尽量避免大量短生存对象。\n\tIO 优化需要识别是否是磁盘瓶颈。例如使用异步 IO、零拷贝、页缓存、顺序写入等方式提升吞吐。对于数据库系统，使用合适的索引、减少回表、启用查询缓存都能提升性能。\n\u3000\u3000网络优化包括减少 RTT、提升带宽利用率、启用连接复用、使用更高效编码格式。例如 gRPC 使用二进制协议 + HTTP/2 就比传统 JSON 更高效。\n\u3000\u3000性能优化必须依赖可观测性。通过 pprof、火焰图、链路追踪、系统监控等机制定位瓶颈，才能做有效优化。\n\u3000\u3000最终，性能优化不是“改一条配置”，而是全链路工程能力的体现。 CreatedAt:2025-11-26T21:18:13+08:00 Author:{Id:0 Name: Avatar:}} {Id:255 ViewCount:0 LikeCount:0 CommentCount:0 Title:分布式 ID 系统设计：雪花算法、Segment 与全局一致性挑战 Content:\u3000\u3000分布式 ID 是大型系统中的基础组件，用于为全局业务对象生成唯一标识符。在订单、用户、商品、日志、事件等系统中，每秒可能需要生成数十万到数百万 ID，因此分布式 ID 系统必须具备高性能、高可用、低延迟与强一致性。常见 ID 生成方案包括雪花算法（Snowflake）、数据库自增、Segment 块分配、号段缓存、高性能 KV 存储生成等。\n\u3000\u3000雪花算法是一种常见的本地生成算法，通过将时间戳、机器 ID、序列号组合生成 64 位整数，具备高性能、无中心化等优势。但雪花算法需要处理时钟回拨问题，一旦服务器时间出现跳跃，可能导致重复 ID 或顺序错乱。因此在强一致性场景下需要引入时钟监控、单机 fencing 机制等。\n\u3000\u3000Segment（号段）模式通过数据库或服务端下发一段连续 ID 给应用，应用在本地使用这段 ID 生成器，直到耗尽。Segment 模式可以实现百万级 QPS，但数据库成为瓶颈，因此需要使用多主模式、读写分离、预分配缓存等方式提升性能。\n\u3000\u3000高一致性场景下需要使用中心化 ID 服务。例如基于 Etcd 的 CAS 操作生成全局递增 ID；基于 Redis 的 INCR 原子操作生成分布式 ID。对于更高要求的系统，可以使用自研分布式 ID 生成器，如 Meituan 的 Leaf、Twitter 的 Snowflake 变种等。\n\u3000\u3000最终，分布式 ID 系统不是简单生成数字，而是一个关乎性能、可靠性、一致性的核心基础设施组件。 CreatedAt:2025-11-26T20:44:30+08:00 Author:{Id:0 Name: Avatar:}} {Id:265 ViewCount:0 LikeCount:0 CommentCount:0 Title:云原生存储 CSI 深度解析：卷插件、快照与多租户隔离 Content:\u3000\u3000Kubernetes 中的存储由 CSI（Container Storage Interface）统一管理，CSI 插件提供挂载卷、动态创建 PV、快照恢复、克隆卷、扩容等核心能力。在云原生架构中，存储不再是“固定盘”或“手动挂载”，而是完全由集群调度动态管理的资源。CSI 的出现使得存储具备高度扩展性、跨供应商兼容性与自动化能力。\n\u3000\u3000CSI 的核心组件包括控制器服务与节点服务。控制器服务负责创建卷、删除卷、快照、克隆、扩容等；节点服务负责挂载卷、卸载卷、格式化卷等操作。所有操作都通过 gRPC 调用进行，确保插件能够跨平台运行。\n\u3000\u3000快照与克隆是云原生存储最强大的能力之一。快照可以在几毫秒内创建卷的逻辑副本，适用于备份、快速恢复、测试环境克隆等场景。克隆卷则可以用于创建相同数据的测试环境，实现快速布署。\n\u3000\u3000多租户隔离是企业级存储必须解决的问题。CSI 需要与 Kubernetes RBAC、StorageClass、Quota 配合，实现不同租户之间的配额隔离、访问隔离以及存储策略隔离。对于金融级需求，还需要结合加密、审计与专有存储节点进一步增强安全性。\n\u3000\u3000最终，CSI 将存储能力抽象化，使得存储在云原生体系中像计算一样可以弹性调度，是现代集群架构不可或缺的一部分。 CreatedAt:2025-11-26T19:11:04+08:00 Author:{Id:0 Name: Avatar:}} {Id:220 ViewCount:0 LikeCount:0 CommentCount:0 Title:Go Runtime 深度解析：调度器、内存管理与垃圾回收机制 Content:\u3000\u3000Go Runtime 是 Go 语言性能与并发能力的核心，其内部的调度模型、内存管理策略、垃圾回收机制共同构成了 Go 高性能服务的基础。理解 Runtime 的工作原理，不仅能帮助开发者写出更高效的代码，还能在面对高并发、内存泄漏、GC 停顿等问题时快速定位原因。\n\u3000\u3000Go 的调度器基于 GMP 模型，其中 G 代表 goroutine，M 代表 OS 线程，P 代表逻辑处理器。P 决定可并行执行的 G 的数量，M 负责实际运行 G。Work Stealing 算法让不同 P 之间可以互相窃取任务，从而实现更高的调度效率。\n \u3000 内存管理采用 tcmalloc 风格的小对象分配器，通过 span、page、cache 多级结构降低锁竞争。在多线程环境下，Go 会为不同 P 分配本地缓存，避免频繁加锁。\n\u3000\u3000垃圾回收机制从 Go1.5 后逐步优化到低延迟 GC，通过三色标记法、写屏障、并发标记等方式减少 stop-the-world 时间。但开发者仍需要减少逃逸、避免频繁申请小对象、使用 sync.Pool 等降低 GC 压力。\n \u3000 最终，深入理解 Go Runtime 能显著提升程序性能与稳定性，使开发者能够从底层视角优化系统。 CreatedAt:2025-11-26T18:24:15+08:00 Author:{Id:0 Name: Avatar:}}]"
